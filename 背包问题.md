## 各种的背包问题
> 参考博客 https://blog.csdn.net/stack_queue/article/details/53544109
### 零一背包
零一背包问题是最简单的也是其他背包问题的基础
递推公式为f[i][v] = Max{f[i-1][v],f[i-weight[i]]+value[i]}。下面代码是简化版本，有几个要注意的点，1）第二个循环是从大到小的 2）dp数组的初始值全为0，这代表了只求背包能装下的最大价值，如果除了dp[0]为零以外，其余dp[i]全为负无穷，则表示背包恰好装满的最大价值。
```
    public static void OneZeroPack(int value,int weight,int[] dp,int packWight){
        for(int i = packWight;i >= weight;i--)
            dp[i] = Math.max(dp[i],dp[i-weight]+value);

    }
    public static int OneZeroPackProblem(int[] value,int[] weight,int packWeight){
        int[] dp = new int[packWeight+1];
        for(int i=0;i < value.length;i++ ){
            OneZeroPack(value[i],weight[i],dp,packWeight);
        }
        return dp[packWeight];
    }
```
### 完全背包
完全背包相对于零一背包，多了一个数量不限的条件。完全背包问题有以下几种思路 
#### 思路1
递推公式为
f[i][v] = Max{f[i-1][v],f[i-1][v-k* weight[i]]+ k * value[i]} k是从1 到v /weight[i]。这样的复杂度就是O(V * Weight * K)
下面有两种优化
第一是剔除一些多余的物品，比如价值低并且重量大的物品。
第二是将完全背包转换成零一背包，即将第i个物品转换成费用为c[i] * 2^k、价值为w[i] * 2^k的若干件物品，其中k满足c[i] * 2^k<=V。这是二进制的思想，因为不管最优策略选几件第i种物品，总可以表示成若干个2^k件物品的和。这样把每种物品拆成O(log(V/c[i]))件物品，是一个很大的改进。
#### 思路2
将第二个循环从小到大，因为对于零一背包来说从大到小是为了不再挑选已经挑选过的物品，但是完全背包却可以再次挑选。
另一种解释是递推公式为 f[i][v] =  Max{f[i-1][v],f[i][v-weight[i]] + value[i]},这样第二个循环就是从小到大。
```
    public static void CompletePack(int value,int weight,int[] dp,int packWight){
        for(int i= weight;i <= packWight;i++)
            dp[i] = Math.max(dp[i],dp[i-weight]+value);
    }
    public static int CompletePackProblem(int[] value,int[] weight,int packWeight){
        int[] dp = new int[packWeight+1];
        for(int i = 0;i < value.length;i++){
            CompletePack(value[i],weight[i],dp,packWeight);
        }
        return dp[packWeight];
    }
```
### 多重背包
多重背包相对于完全背包，条件改为每个物品有一定的数目。这样我们可以用之前谈到的思路，就是用二进制的思路，将第i个物品转换为若干个物品，比如一个物品有13个，那么就可以当做有1,2,4,6这4种物品。这样就转换成为零一背包问题了。
```
    public static void MultiplePack(int value,int weight,int num,int[] dp,int packWeight){
        if(weight * num >= packWeight)
            CompletePack(value,weight,dp,packWeight);
        else{
            int k = 1;
            while(k < num){
                OneZeroPack(k*value,k*weight,dp,packWeight);
                num -=k;
                k <<= 1;
            }
            OneZeroPack(num*value,num*weight,dp,packWeight);
        }
    }
    public static int MultiplePackProblem(int[] value,int[] weight,int[] num,int packWeight){
        int[] dp = new int[packWeight+1];
        for(int i = 0;i < value.length;i++)
            MultiplePack(value[i],weight[i],num[i],dp,packWeight);
        return dp[packWeight];
    }
```
### 二维费用背包
```
```
